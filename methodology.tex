\chapter{Experimental Methodology}
\label{cha:methodology}

This chapter discusses the methodology and matrices we used to evaluate the performance
of the Garbage-First family of garbage collectors. This involves the discussion of
the software and hardware platform we used for benchmarking,
the benchmarking programs we used and the 
matrices we evaluated on all the previously implemented garbage collectors.

\section{Software platform}
\label{sec:softplat}

\subsection{JikesRVM}

We did all the GC implementations and evaluated all performance matrices on JikesRVM.
JikesRVM is a research purpose Java virtual machine. It is a meta-circular JVM
which is implemented in the Java programming language and is self hosted.
JikesRVM was designed to provide a flexible open sourced test-bed to
experiment with virtual machine related algorithms and technologies.

In stead of executing Java programs by directly interpreting the Java byte code,
JikesRVM compiles them into machine code for execution.
JikesRVM implemented two tiers of compilers, the baseline compiler and the optimizing compiler.
The baseline compiler simply translates the Java byte code into machine code and do no
optimizations while the optimizing compiler performs several optimizations during the
code generation phase. We performed all benchmarking and analysis works on the
optimized build of the JikesRVM.

\subsection{MMTk}

The GC implementations are done using MMTk, which is a memory management toolkit.
The MMTk is used as a memory management module for JikesRVM and is responsible for
memory allocation and garbage collection. MMTk defines several address spaces to
allocate different type of objects. e.g. \textjava{NonMovingSpace} for non-copyable objects
and \textjava{SmallCodeSpace} for storing java code.

All of the G1 family of garbage collectors involves two major phases, the marking phase
and the evecuation phase. Instead of using the MMTk's pre-defined \textjava{PREPARE -> SCAN ROOTS -> CLOSURE -> RELEASE}
collection phase which only performs a single tracing on the heap, we extended this
to perform a seperate full or partial heap tracing or linear scanning phase for
evacuation and reference updating.

MMTk will check for stop-the-world or concurrent garbage collection after each
requested space allocation.
This involves the invocation of methods \textjava{collectionRequired(...)}
and \textjava{concurrentCollectionRequired(...)}.
Our implementations made full use of these two methods,
not only for checking whether a collection is required,
but also performs switching between different list of collection phases
for either nursery or mature collection for the G1 collector.

\section{Hardware platform}
\label{sec:hardplat}

\subsection{Development}
 
All of the G1 family of garbage collectors in chapter~\ref{cha:implementation}
were tested on a wide range of machines, as shown in Table~\ref{tab:machines}.
The main developement of 
By testing the These machines has a large varities on CPU types, clock, number of processors and
the size of cache and memory. By testing 

\begin{table*}
  \centering
  \label{tab:machines}
  \input table/machines.tex
  \caption{Machines used for development and evaluation.}
\end{table*}

\subsection{Benchmarking and Evaluation}



\section{Hardware platform}
\label{sec:hardplat}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 


% We can also refer to specific lines of code in code listings. The bug in
% \Cref{fig:c:hello} is on \cref{line:bug}. There is also a bug in
% \Cref{fig:java:hello} on \crefrange{line:jbug-start}{line:jbug-end}. To
% achieve these references we put
% \texttt{(*@ \textbackslash label\{line:bug\} @*)}
% in the code -- the \texttt{(*@ @*)} are escape delimiters that allow you to add
% LaTeX in the (otherwise verbatim) code file.

% \begin{table*}
%   \centering
%   \caption{Processors used in our evaluation.  Note that the caption for a table is at the top.  Also note that a really long comment that wraps over the line ends up left-justified.}
%   \label{tab:machines}
%   \input table/machines.tex
% \end{table*}

% \begin{figure}
%   \centering
%   \begin{subfigure}[b]{\textwidth}
%       \lstinputlisting[linewidth=\textwidth,breaklines=true]{code/hello.c}
%       \caption{C}
%       \label{fig:c:hello}
%   \end{subfigure}

%   \begin{subfigure}[b]{\textwidth}
%       \lstinputlisting[linewidth=\textwidth,breaklines=true]{code/hello.java}
%       \caption{Java}
%       \label{fig:java:hello}
%   \end{subfigure}

%   \caption{Hello world in Java and C. This short caption is centered.}
%   \label{fig:helloworld}
% \end{figure}