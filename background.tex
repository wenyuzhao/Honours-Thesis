\chapter{Background and Related Work}
\label{cha:background}

This chapter describes the background and basic ideas of several garbage collectors,
particularly those targeting the java virtual machine and are implemented in OpenJDK or JikesRVM,
as well as the differences among several garbage collection techniques.

In addition, this chapter also performed a general discussion of the related work
on analyzing region-based garbage collectors.
\\\\
Section~\ref{sec:gcalgorithms} roughly discusses and compares different class of GC algorithms.
\\\\
Section~\ref{sec:g1collectors} describes the general design of the Garbage-first family of garbage collectors.
\\\\
Section~\ref{sec:relatedwork} describes the related work on analyzing region-based garbage collectors.
\\\\

\section{JikesRVM and MMTk}

The whole project discussed in this thesis are based on JikesRVM and all the garbage collectors
I implemented and evaluated in this project are all implemented by using MMTk.
In this section I will briefly discuss the design of JikesRVM and MMTk,
as well as some description on the general structure of them.

\subsection{JikesRVM}

JikesRVM is a research purpose Java virtual machine and was firstly released by \cite{alpern2005jikes}. It is a meta-circular JVM
which is implemented in the Java programming language and is self hosted.
JikesRVM was designed to provide a flexible open sourced test-bed to
experiment with virtual machine related algorithms and technologies.

In stead of executing Java programs by directly interpreting the Java byte code,
JikesRVM compiles them into machine code for execution.
JikesRVM implemented two tiers of compilers, the baseline compiler and the optimizing compiler.
The baseline compiler simply translates the Java byte code into machine code and do no
optimizations while the optimizing compiler performs several optimizations during the
code generation phase. I performed all benchmarking and analysis works on the
optimized build of the JikesRVM.

\subsection{MMTk}

MMTk is a memory management toolkit.
MMTk is used as a memory management module for JikesRVM and is responsible for
memory allocation and garbage collection.

For memory allocation, MMTk defines several address spaces to
allocate different type of objects. e.g. \textjava{NonMovingSpace} for non-copyable objects
and \textjava{SmallCodeSpace} for storing java code. After receving a allocation request,
MMTk will decide which space the object belongs to and allocate memory from that space.

All of the G1 family of garbage collectors involved in this thesis involves two major phases,
the marking phase and the evecuation phase.
Instead of using the MMTk's pre-defined \textjava{PREPARE -> SCAN ROOTS -> CLOSURE -> RELEASE}
collection phase which only performs a single tracing on the heap, I extended this
to perform a seperate full or partial heap tracing or linear scanning phase for
evacuation and reference updating.

MMTk will check for stop-the-world or concurrent garbage collection after each
requested space allocation.
This involves the invocation of methods \textjava{collectionRequired(...)}
and \textjava{concurrentCollectionRequired(...)}.
I made full use of these two methods,
not only for checking whether a collection is required,
but also performs switching between different schedule of collection phases
for either nursery or mature collection for the G1 collector.

\section{Categories of GC Algorithms}
\label{sec:gcalgorithms}

This section discusses the main classes of garbage collection algorithms, as well
as their pros and cons.

\subsection{Reference counting}

Reference counting is a widely used garbage collection technique which tracks the
count of references for each heap allocated object (\cite{detlefs2002lock}).
The reference count for a object is increased when a new variable references to
the object and decreased when a reference
to the object is deleted or goes out of its declaring scope. The reference count for
a object is initialized to one when the object is created, which means there is only one
owner for the object (its creater). When the reference count of the object goes
to zero, it is certain that the object has no owner that references to it. Then the
object becomes floating garbage and its occupying memory is released.

In order to track the reference count for each object, a write barrier is involved
for reference counting collectors.
For each object reference modification \textjava{obj.x = y}, the reference count of
the old object reference is decreased and the reference count of the new object reference
is increased by $1$. If the old object reference has no owner, then its memory cell gets sweeped immediately.

This collection algorithm is highly efficient and the workload for sweeping objects are
almost evenly distributed which makes the mutator pause time for reference counting
to be extremely short.

However, one major disadvantage of the reference counting GC is that it can hardly
handle cyclic references (\cite{lins1992cyclic}) where some object \textjava{A} references the other object
\textjava{B} and \textjava{B} also references \textjava{A}. In such case the reference
count is at least $1$ for both \textjava{A} and \textjava{B}, even if there is no
objects referencing to them.

\subsection{Mark \& Sweep GC}

Mark and Sweep GC is a type of tracing GC which uses the object graph to assist with garbage collection.
The algorithm considers all the objects that is the unreachable in the program as garbage (\cite{endo1997scalable}).
In this way Mark and Sweep GC has the ability to collect cyclic referenced garbages,
as long as they are unreachable from other live objects.


When allocating objects or requesting memory pages from some memory resource,
the mutators dose no extra work but only checks whether the memory is full.
If there is no free space for allocation, the execution of all the mutators will be
paused and the Mark and Sweep GC is triggered.

The Mark and Sweep GC requires an extra metadata byte in the object header for marking.
During each GC cycle, the Mark and Sweep GC firstly scans and marks all the static object,
global objects and stack variables as a set of "root objects".
Then the collector starting from the root objects and recursively walks over the
object graph to mark all the remaining objects. At the end of the marking phase,
all the marked objects in the heap are reachable from the "root set" and all other
objects become floating garbage and are sweeped.

After a GC cycle, all the paused mutators are resumed to continue execution and allocation.

The Mark and Sweep GC has the ability to collect cyclic referenced garbages by tracing
the reachability of heap objects. However, as the use of large-scaled servers and
other programs for business becomes more and more porpular, the Mark and Sweep GC 
reveals its drawback that it can cause significant memory fragmentation after a
sufficiently long running time. Because when the collector keeps allocate and free
small memory chunks, the size of contiguous free chunks becomes smaller, which may
leads to allocation failure for large objects, even if the total free memory size
is larger than the requested chunk size.

\subsection{Copying GC}

Copying GC is a class of garbage collectors that aims to reduce heap fragmentation
by performing heap compation, which moves objects in the heap together.

As one of the most simple copying GC, the SemiSpace GC divides the whole heap
into two spaces, the from-space and the to-space. All objects allocation are done
within the from-space. When the from-space is exhausted, a GC cycle is triggered.
The collector will starting from all root objects, and recursively walks over the
object graph to copy all reachable objects to the to-space. Then the to-space becomes
the new from-space for further allocation. In this way the SemiSpace GC ensures all
live objects are copied to the to-space and all non-reachable objects (i.e. dead objects)
are not forwarded and are sweeped at the end of the GC cycle.

Copying GCs has the ability to reduce heap fragmentation but can cause longer
pause time for each GC cycle. Especially for some GCs which has additional evacuation
phase at the end of a marking phase, e.g. the MarkCompact GC.

\section{Garbage-First Family of Garbage Collectors}
\label{sec:g1collectors}

This section will give a brief introduction the three most popular Garbage-first
family of garbage collectors. For each collector, the basic algorithm
and the past and current status will be discussed.

\subsection{Garbage-First GC}

Garbage-First GC is a copying collector which was initially released in Oracle JDK 6
and was fully supported in Oracle JDK 7. G1 was designed as server-style collector
which targeting machines with multi-processors and large memories. 

G1 GC divides the whole heap up into some fiexed sized regions. 
As a copying collector, G1 GC tries to reduce the pause time for evacuating objects
by performing evacuation on a subset of regions (called the collection set) instead of
all allocated regions.

The collection cycle of the Garbage-First GC starts with a concurrent marking phase
which the collector threads marks all the objects in the heap, just like the Mark \&
Sweep GC, but without pausing the mutators.
After the marking phase, the G1 collector selects the collection set which contains
the regions with smallest ratio of live objects.
Then the collector evacuates live objects in the collection set.

In order to perform evacuation on a subset of regions, the collector uses a data structure
called "remembered set" to remember all uses of the objects in the collection set.
After these live objects are evacuated, the collector scans the remembered set to
update the pointers in other regions that references these live objects.

By performing partial heap evacuation, the G1 GC generally has lower pause time
than other copying GCs, especially on machines with large heaps (\cite{detlefs2004garbage}).
By adjusting the size of the collection set before evacuation, G1 has the ability
to control the pause time to meet some user-defined soft pause time goal.
However, one main drawback of G1 is that it is not suitable for small heaps,
and the implementation of remembered sets can be inefficient.

\subsection{Shenandoah GC}

Shenandoah GC is concurrently an experimental collector for OpenJDK.
Shenandoah GC also divides heap up into regions and performs concurrent marking,
similar to the Garbage-first GC.

Shenandoah GC tries to further reduces the GC latency by performing concurrent
compaction. The concurrent marking phase that Shenandoah GC has is similar to
the G1's concurrent marking phase. However, Shenandoah GC does not have a generational
mode and does not perform pertial evacuation to reduce pause times.
Instead, the Shenandoah GC performs the evacuation phase concurrently to collect
all posible regions, without pausing mutators.

By performing concurrent marking and compaction, Shenandoah GC does most of the
heap scanning work in concurrent. In this way the pause time caused by garbage collection
is extremely small and is not proportional to the heap size.
However, Shenandoah GC has to insert some mutator barriers into the Java program,
before every object reference read and write. So the mutator overhead caused by
these barrier is much greater than other GCs.

\subsection{ZGC}

ZGC is very similar to the Shenandoah GC and is also currently under experimental status.
ZGC performs a refinement on the Shenandoah GC to largely reduces the barrier
overhead.
ZGC assigns a color for each pointer and stores this metadata into the
unused bits in the 64bit pointers.
Instead of inserting barriers on every object reference read and write,
ZGC only uses a "load barrier" which is only inserted before the mutator loads an
object reference from the heap. The barrier is responsible for both object concurrent marking
and evacuation, by checking the "color" metadata in the pointer.
In this way ZGC remarkably reduces the throughput reduction caused by the mutator
barriers.

\section{Related Work}
\label{sec:relatedwork}

\subsection{Implementations and Evaluations of the G1 family of collectors}

The current working G1 family of garbage collectors implemented for modern Java Virtual Machines
includes the Garbage-first GC, Shenandoah GC and ZGC.
All of these three major collectors are implemented in OpenJDK.

\cite{detlefs2004garbage} designed and evaluated the basic algorithm of the Garbage-First collector,
including the original design of the pure(non-generational) and generational version
of G1 GC. Based on this, G1 GC was firstly implemented and released as an alternative
experimental GC for OpenJDK 7. \cite{flood2016shenandoah} designed the basic algorithm
of the Shenandoah garbage collector.
Based on this, Shenandoah GC was firstly implemented as an alternative experimental GC for OpenJDK 8.
ZGC is a new garbage collector designed and implemented for OpenJDK
and has justly released the the first experimental version in OpenJDK 11.

\citep{detlefs2004garbage,flood2016shenandoah} evaluated the performance of G1 GC
and Shenandoah GC respectively, including the pause time and mutatur barriers overhead.
However, their evacuations uses different benchmarking program and are done within
different hardward platform. In addition, the implementations between these collectors
varies too much, even for parts that shares the common ideas, which makes it hard to
compare the benchmarking results between G1 GC and Shenandoah GC.

\subsection{Evaluation of region-based collectors}

\cite{gay1998memory} measured the performance of memory management on a region-based heap.
They divided the heap up into regions and used a safe C dialect
with a conservative reference-counting collector to manage the memory. Then they
measured the performance of both allocation and collection over such region-based heap,
on a collection of realistic benchmarks. They found that the region structure has
advantages for memory allocation and collection, with a competitive performance
compared to malloc/free in C programs and has low overhead when using a garbage collector.
However, they only evaluated the reference counting collector, which is not a
mark and copy collector that this thesis is trying to evacuate. Also, the
language they were using is a safe C dialect, which is different to the Java language
in many aspects.

\cite{qian2002adaptive} implemented a region-based allocator as well as a simple copying
collector on JikesRVM. Based on the evaluation results on SPECjvm98 benchmarks,
they found that the overhead of allocating and releasing memory pages
and the cost of related write barriers is quite low.
However, they are not focus too much on evaulating the overhead on a wide range of
additional memory management techniques built upon the region-based memory structure,
such as concurrent marking or evacuation.

\subsection{Evaluation of barrier overheads}

\cite{yang2012barriers} evaluated a wide range of different read and write barriers
on JikesRVM, using the DaCapo benchmarks and the SPECjvm98 benchmarks.
Also they observed the barrier performance differences of in-order and out-of-order machines.
They found that write barriers are generally has overheads of 5.4\% while write
barriers has average overheads of 0.9\%. However, these barriers evaluations did not
include the evacuation on the Brooks indirection barriers. In addition, this paper
measured the behavior of card marking barriers but did not measure the overhead of
remembered-set barriers which is used along side with the card marking barrier in
the Garbage-first GC.

\section{Summary}

In this section I introduced the background and basic ideas of several garbage collectors and
also performed a general discussion of the related work on analyzing region-based garbage collectors.

Next chapter will briefly describe the implementation environment of the collectors implemented
in this thesis, including the high-level design of JikesRVM and MMTk.
