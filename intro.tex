\chapter{Introduction}
\label{cha:intro}


\section{Thesis Statement}
\label{sec:thesisstatement}
1. Relationship 
2. Refinement

I believe A is better than B.\\
You could use \textbackslash fix\{ABCDEFG.\} to
leave your comments, see the box at the left side. \fix{You have to rewrite your
thesis!!!} 

\section{Introduction}
\label{sec:problemstatement}

As the memory size of modern server machines becomes larger, latency time of
garbage collectors for managed programming languages generally becomes longer.
In this way, the designing low-latency real-time garbage collectors has become
a hot topic today. This involves reducing the latency of collectors and
performing heap compaction or evacuation to avoid heap fragmentation.

Garbage-First GC, Shenandoah GC and ZGC are three major concurrent garbage
collectors. They are designed to deduce latency of mutators on large heaps.
All of these garbage collectors divide heap into regions and all use the
Snapshot-at-the-beginning algorithm to concurrently marking
live objects in the heap \cite{yuasa1990real}. Garbage-First performs stop-the-world partial
evacuation to evacuate and release a set of regions which contains most garbage.
It uses remembered-set to remember cross-region pointers for each region.
Instead of full heap tracing to update references after evacuation, G1 reduces
mutator latency by performing partial heap tracing starting from roots and
remembered-sets to update references. Shenandoah ang ZGC further make the whole
evacuation and updating references phases concurrent by using the Brooks style
indirection pointer. To assist with the concurrent evacuation, Shenandoah uses
"Object reference use barriers" while ZGC uses "Object reference load barriers".
By performing concurrent evacuation, the latency time for Shenandoah and ZGC is
much shorter and is not proportional to the heap size.

However, analyzing the original implementations of these three garbage
collectors on OpenJDK is difficult. These three collectors are implemented by
different teams and do not share too much code among the implementations. Also,
since Garbage-First is production ready while Shenandoah GC and ZGC are not,
optimizations among their implementations varies a lot. Thus analyzing the
original OpenJDK implementations becomes impossible.

In order to make detailed and careful analysis on these collectors, we started
from implementing a simple stop-the-world and region-based GC, and made
progressive refinements on it to implemented concurrent-marking region-based GC,
Garbage-First GC, Shenandoah GC and ZGC. All of these garbage collectors share
the same implementation of the region-based heap structure, allocators and
concurrent marking phase (excepted for the stop-the-world region-based GC). In
order to compare these collectors at an algorithmic level, the implementations
are as close as possible to the design of their original papers.

We evaluated the footprint overhead for the remembered-sets of the Garbage-First
GC. We found that remembered-sets can take up to \pending{???}\% of the total
heap. We also evaluated the Brooks barriers overhead for Shenandoah GC and ZGC, the latency
time and the snapshot-at-the-beginning (SATB) barrier time for all collectors
on the DaCapo benchmark suite. SATB barriers can increase the mutator overhead
by \pending{???}\%. Brooks barriers increase the mutator overhead of Shenandoah by
\pending{???}\%. By replacing SATB barrier and Brooks barriers with a simple load
barrier, ZGC shortens the barrier overhead to \pending{???}\%.

The costs and overheads revealed in these three Garbage-First family of garbage
collectors can help garbage collection algorithm designers to identify the main
pros and cons of region-based concurrent collectors and hence enables the
possibility to make further refinements and optimizations to them.

\section{Thesis Outline}
\label{sec:outline}
How many chapters you have? You may have Chapter~\ref{cha:background},
Chapter~\ref{cha:design}, Chapter~\ref{cha:methodology},
Chapter~\ref{cha:result}, and Chapter~\ref{cha:conc}.
