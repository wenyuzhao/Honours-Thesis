\chapter{Introduction}
\label{cha:intro}

This thesis explores the Garbage-First family of garbage collectors, including
the underlying relationship among them, the improvements each GC does and the performance
contribution by each algorithmic component.
My thesis is that different Garbage-First family of collectors are strongly related
and each collector is actually an improvements to other existing collectors.
These improvements increases the GC performance in some aspect but also cause several extra drawbacks.

\section{Project Statement}

As the memory size of modern server machines becomes larger, latency time of
garbage collectors for managed programming languages generally becomes longer.
In this way, the designing of low-latency garbage collectors has become
a hot topic today. This involves reducing the latency of collectors and
performing heap compaction or evacuation to avoid heap fragmentation.

% Current three collectors
Among all the existing low-latency garbage collectors, the category of region-based
collectors is widely explored and used in modern industry.
Region-based collectors are designed to reach high GC
performance (especially GC pause times) by managing the heap as a set of memory regions.
As four well-known region-based garbage collectors,
Garbage-first GC, Shenandoah GC, C4 GC and ZGC created by
\citep{detlefs2004garbage,flood2016shenandoah,tene2011c4,liden_karlsson_2018} respectively
are high performance region-based garbage collectors implemented for Java virtual machines
to reach short GC pause times and high program throughput.

% Problem
The design and implementation of such region-based collectors has been well
explored nowadays, but unfortunately their underlying relationship is still remains unidentified and unexplored.
Although these collectors share a lot of basic algorithms and structures,
the original papers or other publications of these collectors only regard them as
newly created and stand-alone collectors instead of improvements to the existing collectors.
Such ignorance of the potential relationships prevents GC designers to have a clear
overview of the algorithms supporting these collectors.

Also, the lack of explorations on these relationships can make the GC performance evaluation
and analysis among these collectors to be impossible.
The existing G1 family of collectors, including
G1 GC, Shenandoah GC, C4 GC and ZGC are invented by different groups or campanies (Sun, RadHat, Azul and Oracle respectively).
The implementations and optimizations on these collectors are vary.
This makes the original implementations of the G1 family of collectors do not reflect
their underlying structural relationships.
The implementation differences among these collectors make them become impossible
to be carefully measured for the GC performance impact of each structural component.
This means no one have ever truely understand the GC performance contribution of each
GC algorithm involved in these collectors.
On the one hand such lack of explorations on these relationships and the lack of
performance analysis and comparisons may cause some unexpected performance issue to these collectors.
As an example, according to \cite{briandemsky2015speculative}, sometimes GC time of region-based collectors
can take up to 50\% of the total execution time of Big Data systems.
On the other hand this can also mislead the future design of related collectors.

So here come to the problem which this thesis is aiming to solve: What are the relationships
among the G1 family of collectors and in which way will they contribute to the GC performance?

% Challenge
% The challenge is: \pending{XXX}?


% As the three major concurrent region-based garbage collectors in OpenJDK, 
% Garbage-First GC and Shenandoah GC share most of their collection policies and techniques.
% Both of these two GCs were designed to deduce latency of mutators on large heaps.
% They share the same heap structure which divides the heap up into regions.
% During GC cycle, both of these two GCs perform similar marking and
% heap compaction processes.
% Although the specific algorithms and implementation details are very, these two
% GCs reveal strong relationships to each other and share plenty of common parts and general ideas.

% These Garbage-First family of garbage collectors were designed to reduce GC latencies,
% their performances sometimes can be unsatisfactory. Sometimes GC time of region-based collectors
% can take up to 50\% of the total execution time of Big Data systems (\cite{briandemsky2015speculative}).
% In this way it is necessary to perform careful analysis of the pros and cons for the 
% Garbage-First family of garbage collectors, especially on an algorithmic level.

% However, analyzing the original implementations of these three garbage
% collectors on OpenJDK is difficult. These three collectors are implemented by
% different teams and do not share too much code among the implementations. Also,
% since Garbage-First is production ready while Shenandoah GC is still provided as an
% experimental GC option in OpenJDK, optimizations among their implementations varies a lot.
% Thus analyzing the original OpenJDK implementations becomes impossible.

% This thesis aims to perform an more careful analysis and comparison among all the 
% Garbage-First family of garbage collectors by implementing these collectors on JikesRVM
% and sharing as much implementation as possible.

\section{Contribution}

I insist that the G1 family of collectors are strongly related to each other,
although the original papers of these collectors present them as a stand-alone collector
instead of a improved collector based on other existing GC algorithms. The lack of
explorations to such structural relationships makes it hard to carefully analyze
the performance contribution caused by each part of the GC algorithm, hence prevents
GC designers to truly understand the pros and cons of each GC algorithms.

This thesis makes a deep exploration to the underlying relationship among the
G1 family of garbage collectors. The algorithmic relationships are summarised
as a series of progressive improvements, which generally reflects the evolution
history of the G1 family of collectors.

As another major component of the exploration, I implement the collectors by following
the steps of the progressive improvements, staring from a most simple form of the
region-based collector to the most complex collector, e.g. Garbage-First GC and
Shenandoah GC, to reveal the hierarchy of the G1 family of collectors.
GC performance of these implemented collectors are also evaluated and discussed.

The general steps involved in thie thesis for exploring these collectors includes:

\begin{quote}
  \textbf{Discover the relationships}
    of the G1 family of garbage collectors includs understand the basic algorithms
    of these collectors, infer the underlying relationships among them and reconsider them as
    a series of algorithm improvements instead of individual collectors.

  \textbf{Implement a simple mark-region collector}
    by starting from an existing SemiSpace GC in MMTk and replace the two copy-spaces
    with a region-space which divides the memory up into multiple regions.
    Then adding an extra marking phase before the evacuation phase.

  \textbf{Perform a series of improvements}
    by starting from the simple mark-region collector and progressively perform
    improvements including linear-scan evacuation, concurrent marking, remembered sets
    and concurrent evacuation. This step produces a few improved version of the
    mark-region collectors, the Garbage-First GC and the Shenandoah GC.

  \textbf{Measure the GC performance}
    includes measuring the GC pause times of all implemented collectors, the 
    barrier overheads and the remembered set size. This measurements reflect the
    performance gain caused by each algorithmic improvement.

  \textbf{Explain and explore the results}
    of the previously generated measurement results, which leads to a reconsideration
    of the pros and cons of each G1 related GC algorithms in depth.
\end{quote}

A total of six different Garbage-First family of garbage collectors were implemented to reveal
the relationships among them and demonstrate different kinds of garbage collection
algorithms, such as concurrent marking, remembered-sets and Brooks barriers.

In order to make detailed and careful analysis on these collectors and
be able to compare these collectors at an algorithmic level, the implementations
are as close as possible to the design of their original papers.

I measure the GC pause times for each implemented collectors, as well as the mutator
ooverheads of the mutator barriers involved in these collectors, including
snapshot-at-the-beginning (SATB) barrier, remembered-set barrier and the Brooks barrier.
I found that concurrent marking contributes to a decrease of the average GC pause time by \pending{???}\%
where linear scanning evacuation increases the average GC pause time by \pending{???}\%.
However, the use of remembered-sets can reduces the GC pause time up to \pending{???}\%.
As the result of barrier latency analysis, I found that SATB barriers can
increase the mutator overhead by \pending{???}\% where Brooks barriers
increase the mutator overhead of Shenandoah GC by \pending{???}\%.

All work were done in JikRVM, a research purpose Java virtual machine and MMTk,
a memory management took written in java (\cite{blackburn2004oil}).

\section{Thesis Outline}

Chapter~\ref{cha:background}
provides an general background and an overview of the Garbage-First family of garbage collectors.
Similarities and differences among some major categories of garbage collectors are discussed as well.
Also the related work on implementing and measuring region-based collector and G1 family
of collectors are discussed.
\\\\
Chapter~\ref{cha:implementation} provides the detailed steps and algorithms of the implementation of
all the Garbage-First family of garbage collectors.
\\\\
Chapter~\ref{cha:evaluation}
describes the methodology used for evaluating the implemented collectors,
including the benchmark involved and the detailed steps of each evaluation.
This chapter also presents the results of the evaluation and benchmarking on the implemented collectors,
as well as detailed and critical discussion on the evaluation results of the
implemented collectors.
\\\\
Chapter~\ref{cha:conc} discusses the work related to this project that I plan to do in the future and the conclusion of this thesis.